

# 介绍

::: danger  介绍项目

这个项目是公司最重要的项目

**权限分成三部分**

超级管理员 

-  全部页面

管理员		

- 除了 权限管理   用户提现模块    

代理			

- 用户管理模块，只能禁用
- 可视化模块

**模块有**  分为9个主要模块

1. 用户管理模块
2. 代理管理模块
3. 游戏设置模块
4. 用户提现模块
5. App更新模块
6. 问卷列表低代码模块
7. 公告模块
8. 可视化模块
9. 权限管理

:::

## 一	路由权限管理，按钮级别权限管理

::: danger  权限一般分为两大部分

1.路由页面级权限

2.按钮级别权限

不同的账号显示的菜单栏不同，页面上可以操作的按钮也不一样，这些操作都是通过权限模型实现的，那么接下来我们就来学习下常见的权限模型

:::

### RBAC（角色的访问控制模型）

RBAC 模型的基本思想是将用户和权限分离，通过角色作为中间层来连接用户和权限

一个角色可以关联多个权限，一个用户可以拥有多个角色。这样可以实现灵活的权限配置和管理，避免直接给用户分配权限带来的复杂性和冗余性。

![image-20240904133700056](../public/image-20240904133700056.png)

比如我现在请求接口

肯定你和后端商量，比如现在

**分成3个权限**

最高级管理员（老板）  super

管理员  						admin

代理							group

### 四个按钮

  查看       修改        删除      禁用   

  look	 change	 delete		stop    all

### **最后组合起来**

```json
"super.look.change.delete.stop.all"
```

然后可以分成 每个权限的设置

```json
返回的是
{
code:200,
msg:"获取成功"
data:{
    xxxx:
    auth:"super.look.change.delete.stop.all"
},
}
```





关于 按钮级别的权限，可以对按钮进行封装

```tsx
// AuthBtn
import React, { useState, useEffect, useRef } from 'react';
import { Button } from 'antd';

const AuthBtn: React.FC<{}> = (props) => {
  let { authId, children } = props;
  // btnIds 应该有后台接口返回，告诉前端用户有哪些按钮权限
  let btnIds = ['read', 'edit'];
  let hasAuth = btnIds.includes(authId);
  // 这里可以根据实际需求封装
  return <Button disabled={!hasAuth}>{children}</Button>;
};
export default AuthBtn;

// index.ts
<AuthBtn authId="read">read 只读权限</AuthBtn>
<AuthBtn authId="write">write 写入权限</AuthBtn>

```

如果我一开始分成三部分





### 前端是路由写死

::: danger  实现思路

这种方案的核心就是首先在 `routes` 里面事先定义好路由的权限，然后在高阶组件里面进行权限逻辑判断。看用户所拥有的角色和我们配置在路由里面的 `roles` 是否相匹配。匹配则允许进入，不匹配则重定向到无权限提示页面。

:::







### 前端动态添加路由



