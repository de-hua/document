# 专业技能

```
Promise，原型，原型链，闭包，事件循环，熟悉Es6，
React常见性能优化
熟悉打包上架，有相关优化经验
前端工程化、组件化
```

## Promise

思路：

先讲是为了解决回调地狱的问题

在讲promise的三种状态  

- **Pending（进行中）**：初始状态，既没有被兑现（fulfilled），也没有被拒绝（rejected）
- **Fulfilled（已完成）**：意味着操作成功完成
- **Rejected（已失败）**：意味着操作失败

promise方法  

```
then(onFulfilled, onRejected)
catch(onRejected)
finally(onFinally)

静态方法
Promise.all(iterable)
Promise.race(iterable)：
Promise.resolve(value)
Promise.reject(reason)
```

`async`函数会隐式地返回一个Promise，而`await`表达式可以暂停async函数的执行，等待Promise处理完成后再继续执行async函数并返回结果。这使得异步代码看起来和同步代码非常相似，从而大大简化了异步编程的复杂性

## 原型，原型链

在JavaScript中，**原型（Prototype）**和**原型链（Prototype Chain）**是理解对象之间关系和继承机制的核心概念。

### 原型（Prototype）

每个JavaScript对象（除了`null`和`undefined`）在创建时都会与一个原型对象关联。这个原型对象可能也有自己的原型，从而形成了一个原型链。原型对象中的属性和方法可以被对象本身所继承。在JavaScript中，对象的`__proto__`属性（尽管不是标准属性，但许多环境都支持）指向其原型对象，而函数（构造函数）的`prototype`属性则用于设置其创建的对象的原型。

### 原型链（Prototype Chain）

原型链是对象通过其原型对象连接起来的一个链式结构。当访问一个对象的属性或方法时，如果对象本身不存在该属性或方法，JavaScript引擎会沿着原型链向上查找，直到找到该属性或方法或到达原型链的顶端（通常是`Object.prototype`，其原型为`null`）。

### 原型链的运作机制

1. **属性查找**：当尝试访问一个对象的属性时，JavaScript会首先检查对象本身是否包含该属性。如果不包含，它会继续检查对象的原型对象，然后是原型的原型，依此类推，直到找到该属性或到达原型链的顶端。
2. **方法继承**：方法继承的实质也是属性查找。当对象调用一个方法时，JavaScript会按照原型链的顺序查找该方法。
3. **构造函数、原型和实例的关系**：构造函数（函数）有一个`prototype`属性，指向一个原型对象。通过构造函数创建的实例对象，其内部`[[Prototype]]`（在ES5之前通常通过`__proto__`访问）会指向构造函数的`prototype`属性所指向的原型对象。

### 终点

```js
console.log(Object.prototype.__proto__); // 输出 null
```

## 事件循环

事件循环（Event Loop）是一种编程模型，用于处理异步事件和任务的执行顺序。在JavaScript等单线程语言中，事件循环是处理异步操作的核心机制。以下是对事件循环的详细解释：

### 1. 基本概念

- **单线程**：JavaScript是单线程的，这意味着它一次只能执行一个任务。为了防止阻塞，JavaScript将任务分为同步任务和异步任务。
- **任务队列**：异步任务不会立即执行，而是会被放入一个或多个任务队列中等待。这些队列遵循先进先出（FIFO）的原则。
- **事件循环**：事件循环是一个不断运行的过程，它检查任务队列中的任务，并按顺序执行它们。

### 2. 工作原理

1. **执行栈（Stack）**：JavaScript引擎首先会执行同步代码，这些代码会被放入执行栈中。执行栈是一个后进先出（LIFO）的数据结构，用于存储待执行的代码块。
2. **任务队列（Task Queue）**：当遇到异步任务（如setTimeout、网络请求等）时，这些任务会被放入任务队列中等待。任务队列遵循先进先出的原则。
3. **事件循环**：当执行栈为空时，事件循环会检查任务队列中是否有任务。如果有，它会将任务从队列中取出并放入执行栈中执行。
4. **微任务（Microtask）**：除了任务队列外，JavaScript还引入了微任务队列。微任务通常与Promise等异步操作相关。在执行完一个宏任务（即任务队列中的任务）后，事件循环会检查并执行所有微任务队列中的任务。

### 3. 执行顺序

- **同步任务**：首先执行，按照代码顺序依次放入执行栈中执行。
- **宏任务（Macro Task）**：包括整体script、setTimeout、setInterval、I/O、UI渲染等。它们被放入任务队列中，等待执行栈为空时由事件循环取出执行。
- **微任务（Micro Task）**：包括Promise.then、async/await等。它们被放入微任务队列中，在每个宏任务执行完毕后立即执行。

### 4. 应用场景

- **前端开发**：在Web开发中，事件循环常用于处理用户交互、网络请求以及定时任务等异步操作，以提高用户体验。
- **后端开发**：在后端服务器开发中，事件循环可以用于处理大量的并发请求，提高服务器的并发能力和性能。
- **网络编程**：事件循环可以用于实现基于事件驱动的网络通信，如使用Node.js的事件循环处理网络请求。

### 5. 总结

事件循环是JavaScript等单线程语言处理异步操作的核心机制。它通过任务队列和微任务队列来管理异步任务的执行顺序，确保程序能够在不阻塞主线程的情况下高效地处理异步操作。

## 闭包

封装和隐藏

```js
function createCounter() {  
    let count = 0; // 这个变量是私有的，外部无法直接访问  
  
    return {  
        increment: function() {  
            count = count + 1; // 内部函数可以访问并修改外部函数的变量  
            return count;  
        },  
        decrement: function() {  
            count = count - 1;  
            return count;  
        },  
        getCount: function() {  
            return count;  
        }  
    };  
}  
  
// 使用闭包  
const counter = createCounter();  
console.log(counter.getCount()); // 输出: 0  
console.log(counter.increment()); // 输出: 1  
console.log(counter.increment()); // 输出: 2  
console.log(counter.decrement()); // 输出: 1  
console.log(counter.getCount()); // 输出: 1  
  
// 注意：我们无法直接访问 `count` 变量，因为它被封装在 `createCounter` 函数的作用域内  
// 尝试访问 `counter.count` 会返回 `undefined`  
console.log(counter.count); // 输出: undefined
```

在这个例子中，`createCounter` 函数创建了一个局部变量 `count`，并返回了一个包含三个方法（`increment`、`decrement` 和 `getCount`）的对象。由于这三个方法是在 `createCounter` 函数的作用域内定义的，它们都可以访问并操作 `count` 变量。然而，由于 `count` 变量是在 `createCounter` 函数内部定义的，它对于外部代码是不可见的，从而实现了封装和隐藏。

这就是闭包的一个典型应用：通过返回一个内部函数（在这个例子中是一个对象，该对象包含了多个方法），我们可以创建具有私有变量的函数。这些私有变量只能通过返回的函数进行访问和修改，从而保证了数据的安全性和封装性。

## React常见性能优化

```json
React应用中常见的性能优化方法主要包括以下几个方面：

减少不必要的渲染：
使用React.memo：对于函数组件，可以使用React.memo进行包裹，以通过浅比较props来避免不必要的重渲染。
使用useMemo和useCallback：在函数组件中，useMemo可以缓存计算结果，useCallback可以缓存回调函数，以避免在每次渲染时都重新计算或重新绑定。

优化列表渲染：
使用唯一的key：在渲染列表时，为每个元素分配一个稳定的key值，以帮助React识别哪些元素是不同的，从而减少不必要的DOM操作。

代码分割和懒加载：
使用React.lazy和Suspense：通过React.lazy函数结合Suspense组件，可以实现组件的按需加载，即用户实际需要时才加载对应的组件代码，从而减小初始加载体积，提高首屏加载速度。
```

## 前端工程化

1. **使用构建工具**：如Webpack、Gulp等，这些工具可以将项目中的代码打包、压缩、合并等操作自动化，提高开发效率。
2. **编写规范的代码**：遵循一定的代码规范，如使用ESLint、Prettier等工具，保证代码风格的一致性，提高可读性。
3. **模块化开发**：将功能拆分成独立的模块，提高代码的复用性和可维护性。可以使用ES模块或者模块打包工具（如Webpack、Rollup等）进行模块加载和打包。
4. **持续集成与持续部署（CI/CD）**：通过CI/CD工具（如Jenkins、Travis CI等），可以在代码提交后自动进行构建、测试、部署等操作，确保项目的质量。
5. **文档管理和注释规范**：编写清晰明了的注释和项目文档，方便团队成员理解和维护代码。
6. **单元测试**：编写和运行单元测试，通过自动化测试来验证代码的正确性和可靠性。
7. **代码审查**：进行代码审查，促进团队成员之间的代码质量交流和知识共享。

# 工作经历

(CI/CD)流水线进
业务代码进行 code review
首屏渲染速度从3s提升到1s

## 业务代码进行 code review

- **总结经验**：Review结束后，可以组织一次简短的会议来总结经验教训，讨论如何改进未来的Code Review流程。
- **知识共享**：鼓励团队成员分享在Review过程中学到的知识和经验，促进团队整体技能的提升。

## 首屏渲染速度从3s提升到1s

FPC  ：快速的FCP意味着用户能够更快地看到页面的内容，减少等待时间，提升用户体验

要将首屏渲染速度从3秒提升到1秒，使用Webpack 5进行性能优化是一个综合性的过程，涉及多个方面的调整和优化。以下是一些关键的步骤和策略，你可以根据项目的具体情况进行选择和调整：

1. 代码分割（Code Splitting）
   - 使用Webpack的SplitChunksPlugin来自动分割公共模块和第三方库。通过合理配置`optimization.splitChunks`选项，可以将公共依赖提取到单独的chunk中，避免重复打包，减少首屏加载的体积。
   - 对于React等现代前端框架，可以利用动态导入（如React的`React.lazy`和`import()`）来实现路由级别的代码分割，按需加载非首屏必要的组件。
2. 资源优化
   - 对于图片资源，可以使用`url-loader`或`file-loader`将小图片转换为Base64编码，直接嵌入到HTML或CSS中，减少HTTP请求。但需注意，Base64编码会使图片体积增大约33%，因此更适用于较小的图片。
   - 对于较大的图片或图标，可以考虑使用雪碧图（CSS Sprites）或WebP、AVIF等更高效的图片格式来减少文件大小。
3. 压缩和优化打包文件
   - 使用`TerserPlugin`（Webpack内置）来压缩JavaScript代码。
   - 使用`MiniCssExtractPlugin`和`OptimizeCSSAssetsPlugin`（或CSSO、clean-css等）来压缩和优化CSS代码。
   - 安装并使用`compression-webpack-plugin`对打包后的文件进行gzip压缩，以减少传输体积。同时，确保服务器也配置了gzip支持。
4. 利用缓存
   - 对打包后的文件进行哈希命名，以便在内容未更改时利用浏览器缓存。
   - 配置HTTP缓存头（如Cache-Control），以控制资源的缓存策略。
5. 减少HTTP请求
   - 合并多个小的JavaScript或CSS文件为一个文件，以减少HTTP请求次数。
   - 使用Webpack的`HtmlWebpackPlugin`来优化HTML文件，自动引入打包后的资源文件，并合并重复的脚本和样式标签。
6. 懒加载
   - 对于非首屏必要的资源，如图片、视频、音频等，可以使用懒加载技术，在需要时才加载这些资源。
   - 在React中，可以使用`React.lazy`和`Suspense`组件来实现组件级别的懒加载。
7. 分析和监控
   - 使用`webpack-bundle-analyzer`插件来分析打包后的文件，了解各个模块的大小和依赖关系，从而进行有针对性的优化。
   - 监控实际生产环境中的页面加载性能，根据数据反馈进行持续优化。
8. 其他优化策略
   - 优化服务器响应时间，确保服务器能够快速响应客户端的请求。
   - 使用CDN来加速静态资源的加载。
   - 启用HTTP/2，利用其多路复用功能来减少TCP连接次数和延迟。

# 项目

## 问卷列表低代码怎么实现？

```
1.json控制的
2.属性
3.
```

## 打包构建速度和代码体积进行优化？

### 优化构建速度

> 1.构建耗时分析    speed-measure-webpack-plugin -D
>
> 2.开启持久化存储缓存    cache
>
> ```json
> cache: {
> type: 'filesystem', // 使用文件缓存
> },
> ```
>
> 3. 开启多线程loader    thread-loader -D
> 4. 配置alias别名   减少路径的复杂度
> 5. 缩小loader作用范围     include  解析  exclude  排除
> 6. devtool 配置

### 优化构建结果

> 1.webpack包分析工具     webpack-bundle-analyzer
>
> 2.抽取css样式文件    mini-css-extract-plugin   开发环境使用**style-looader**,打包模式抽离 **mini-css-extract-plugin**
>
> 3.压缩css     css-minimizer-webpack-plugin
>
> 4.压缩js文件   terser-webpack-plugin
>
> 5.打包文件hash的配置
>
> 6.代码分割第三方包和公共模块    splitChunks
>
> 7.tree-shaking清理js     模式**mode**为**production**时就会默认开启**tree-shaking**
>
> 8.tree-shaking清理未使用css      purgecss-webpack-plugin@4 glob-all -D
>
> 9.资源懒加载    react lazy(() => import('@/components/LazyDemo'))  异步组件  
>
> 10.打包时生成gzip文件   减少静态资源文件大小,压缩率在 **70%** 左右     compression-webpack-plugin -D
>
> ```json
>  gzip on;  
>     gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;  
>     gzip_proxied any;  
>     gzip_vary on;  
>     gzip_comp_level 6;  
>     gzip_buffers 16 8k;  
>     gzip_http_version 1.1;  
> ```
>
> 