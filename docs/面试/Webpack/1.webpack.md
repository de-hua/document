# 介绍

webpack

## 1.Webpack的配置主要有哪些？

1. 入口（Entry）
   - 指定Webpack应该使用哪个模块作为构建其内部依赖图的开始。这可以是单个文件或多个文件。在配置文件中，通过`entry`属性来定义。
   - 例如，单入口配置：`entry: './src/index.js'`。
   - 多入口配置：`entry: { main: './src/index.js', vendor: './src/vendor.js' }`。
2. 出口（Output）
   - 告诉Webpack在哪里输出它所创建的bundles，以及如何命名这些文件。通过`output`属性来定义。
   - 常见的配置项包括`filename`（输出文件的名称）、`path`（输出文件存放的绝对路径）等。
   - 例如：`output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist') }`。
3. 模式（Mode）
   - 通过`mode`属性设置Webpack的运行模式，有`development`、`production`和`none`三种模式。
   - `development`模式会启用开发友好的特性，如调试和详细的输出信息。
   - `production`模式会启用优化特性，如压缩和代码分割。
4. 模块（Module）
   - 用于配置如何处理项目中的不同模块。Webpack默认只能处理JavaScript文件，通过配置Loader可以处理其他类型的文件。
   - 在`module.rules`中定义Loader规则，指定哪些文件应该被哪些Loader处理。
   - 例如，使用`babel-loader`处理ES6语法，使用`css-loader`和`style-loader`处理CSS文件。
5. 插件（Plugins）
   - 用于执行范围更广的任务，如打包优化、资源管理、环境变量注入等。
   - 通过`plugins`数组来定义需要使用的插件。
   - 例如，使用`HtmlWebpackPlugin`自动生成HTML文件，并自动引入打包后的JS文件。
6. 解析（Resolve）
   - 用于配置模块解析规则，如解析模块路径时自动添加后缀名、设置别名等。
   - 通过`resolve`属性来定义。
   - 例如，设置别名：`resolve: { alias: { Components: path.resolve(__dirname, 'src/components/') } }`。
7. 优化（Optimization）
   - 用于配置打包优化策略，如代码分割、压缩优化等。
   - 通过`optimization`属性来定义。
   - 例如，配置代码分割：`optimization: { splitChunks: { chunks: 'all' } }`。
8. 开发服务器（DevServer）
   - Webpack提供了一个可选的本地开发服务器，它使用webpack-dev-server包提供。
   - 通过配置`devServer`属性来定义开发服务器的行为。
   - 例如，设置自动热重载：`devServer: { hot: true }`。
9. 性能（Performance）
   - 用于设置Webpack打包后的文件性能相关配置，如文件大小限制等。
   - 通过`performance`属性来定义。
   - 例如，设置文件大小警告阈值：`performance: { hints: 'warning', maxEntrypointSize: 500000, maxAssetSize: 300000 }`。
10. 源代码映射（SourceMap）
    - 用于在开发过程中将打包后的代码映射回原始源代码，便于调试。
    - 通过`devtool`属性来定义。
    - 例如，使用`devtool: 'inline-source-map'`来生成易于调试的源代码映射。

## 2.有哪些常见的Plugins和Loader？

Loader:

- babel-loader：将ES6+的代码转换成ES5的代码。
- css-loader：解析CSS文件，并处理CSS中的依赖关系。
- style-loader：将CSS代码注入到HTML文档中。
- file-loader：解析文件路径，将文件赋值到输出目录，并返回文件路径。
- url-loader：类似于file-loader，但是可以将小于指定大小的文件转成base64编码的Data URL格式
- sass-loader：将Sass文件编译成CSS文件。
- less-loader：将Less文件编译成CSS文件。
- postcss-loader：自动添加CSS前缀，优化CSS代码等。
- vue-loader：将Vue单文件组件编译成JavaScript代码。

Plugin:

- HtmlWebpackPlugin：生成HTML文件，并自动将打包后的javaScript和CSS文件引入到HTML文件中。
- CleanWebpackPlugin：清除输出目录。
- ExtractTextWebpackPlugin：将CSS代码提取到单独的CSS文件中。
- DefinePlugin：定义全局变量。
- UglifyJsWebpackPlugin：压缩JavaScript代码。
- HotModuleReplacementPlugin：热模块替换，用于在开发环境下实现热更新。
- MiniCssExtractPlugin：与ExtractTextWebpackPlugin类似，将CSS代码提取到单独的CSS文件中。
- BundleAnalyzerPlugin：分析打包后的文件大小和依赖关系。

## 3.Plugins和Loader的区别是什么？

### 一、定义与作用

- Loader
  - **定义**：Loader是Webpack中的一个核心概念，它用于处理源代码文件，将它们转换成Webpack可处理的模块。
  - **作用**：Loader主要用于对源代码文件（如CSS、图片、JS文件中的高级语法等）进行转换和处理，如压缩、打包、语言翻译等。它们专注于文件内容的转换领域。
- Plugin
  - **定义**：Plugin用于扩展Webpack的功能，它并不直接操作文件，而是基于时间机制工作，监听Webpack打包过程中的某些节点执行广泛的任务。
  - **作用**：Plugin的作用范围更广，它可以执行任意类型的任务，如生成HTML文件、压缩代码、提取公共代码、定义环境变量等。Plugin不仅限于打包和资源的加载，还可以处理各种复杂的构建任务。

### 二、使用方式

- Loader
  - 在Webpack的配置文件中，通过`module.rules`属性定义Loader的使用规则。每个规则描述了如何处理特定类型的文件。
  - Loader的使用通常是通过字符串或数组的形式指定在`use`字段中，可以单独使用或组合使用多个Loader。
- Plugin
  - 在Webpack的配置文件中，通过`plugins`数组定义需要使用的Plugin实例。
  - 每个Plugin实例都需要通过`new`关键字创建，并在`plugins`数组中作为元素添加。

### 三、运行时机

- Loader
  - Loader运行在打包文件之前，它们作为模块加载时的预处理步骤，对源代码文件进行转换和处理。
- Plugin
  - Plugin在整个编译周期都起作用，它们可以监听Webpack生命周期中的多个事件，并在合适的时机执行特定的任务。

### 四、示例

- Loader示例
  - 处理CSS文件：使用`css-loader`和`style-loader`将CSS文件转换成Webpack可处理的模块，并将CSS注入到HTML中。
  - 处理图片文件：使用`url-loader`或`file-loader`将图片文件转换成Base64编码或直接复制到输出目录，并在JS文件中引用。
- Plugin示例
  - `HtmlWebpackPlugin`：自动生成HTML文件，并将打包后的JS文件自动引入。
  - `TerserPlugin`：用于压缩和优化JavaScript代码。
  - `CleanWebpackPlugin`：在打包之前删除/dist目录，确保输出目录的清洁。

### 总结

综上所述，Loader和Plugin在Webpack中各有其独特的作用和使用方式。Loader专注于文件内容的转换，而Plugin则更侧重于扩展Webpack的功能和执行复杂的构建任务。

## 4.搭建一个webpack的React环境   (实践出现错误，无法继续，后续在解决)

简介

先介绍一下webpack的核心概念

### 一 初始化项目

#### 1.1初始化项目

```tsx
npm init -y  //初始化
```

#### 1.2创建项目目录

```json
├── build
|   ├── webpack.base.js //公共配置
|   ├── webpack.dev.js  //开发环境配置
|   └── webpack.prod.js //打包环境配置
├── public
│   └── index.html //html模板
├── src
|   ├── App.tsx   //根组件
│   └── main.tsx //项目入口文件
│   ├── page     //其他组件存放文件夹
├── tsconfig.json  //TS配置文件
└── package.json
```

创建对应目录即可（看着是不是非常熟悉，这正是脚手架（webapck，vite）搭建的目录结构）

#### 1.3安装webpack和React18依赖

```bash
npm i webpack webpack-cli -D   //webpack依赖

npm i react react-dom -S    //react依赖

npm i @types/react @types/react-dom -D   //react类型依赖
```

顺便介绍一下安装包  的-D  -S是干什么的

```
简写  -D   开发依赖
全写  --save-dev
顾名思义：只有开发需要，线上是不需要的，比如这@types/react @types/react-dom 类型包
   线上要这干什么，tsx被编译成js了，这些东西是为了开发有提升，写的爽
 

简写 -S    线上依赖(默认)
全写  --save
```

#### 1.4初始化React+TS

public/index.html 文件

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>webapck5+React18+TS</title>
</head>

<body>
  <!-- 根组件挂载的容器节点 -->
  <div id="root"></div>
</body>

</html>
```

tsconfig.json 文件

```json
{
  "compilerOptions": {
    "target": "ESNext",
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "allowJs": false,
    "skipLibCheck": false,
    "esModuleInterop": false,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "Node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx" //使用React JSX的转换方式
  },
  "include": ["./src"] //这个数组指定了要编译的文件的根目录
}
```

src/App.tsx  文件

```tsx
import React from 'react'

export default function App() {
  return <div>Hello World!</div>
}
```

src/main.tsx内容

```tsx
import { createRoot } from 'react-dom/client'
import App from './App'

createRoot(document.getElementById('root')!).render(<App />)
```

### 二 配置基础的React18+TS环境

#### 2.1webpack公共配置   webpack.base.js

配置入口文件

```js
// 公共配置
// webpack.base.js
const path = require('path')

module.exports = {
  entry: path.join(__dirname, '../src/main.tsx'), // 入口文件
}
```

配置出口

```js
// 公共配置
// webpack.base.js
const path = require('path')

module.exports = {
  entry: path.join(__dirname, '../src/main.tsx'), // 入口文件
  output: {
    path: path.join(__dirname, '../dist'), // 打包后的文件存放的地方
    filename: 'static/js/[name].js', // 打包后的文件名
    publicPath: '/' // 打包后的文件的访问路径
    clean: true, // webpack4需要配置clean-webpack-plugin来删除dist文件,webpack5内置了
  },
}
```

配置loader解析ts和jsx

```bash
npm i babel-loader @babel/core @babel/preset-react @babel/preset-typescript -D
```

1. **babel-loader**：这是一个webpack的加载器（loader），用于将ES6+、JSX、TypeScript等语法编写的文件转换成浏览器兼容的JavaScript代码。它依赖于Babel及其预设（presets）和插件（plugins）来实现转换。
2. **@babel/core**：这是Babel的核心库，提供了转换代码的功能。它本身不包含任何预设或插件，需要与其他Babel包（如预设和插件）一起使用来执行转换。
3. **@babel/preset-react**：这是一个Babel预设（preset），用于支持JSX语法（React的语法糖）的转换。它允许Babel理解JSX并将其转换为React.createElement()调用，以便在浏览器或Node.js环境中运行。
4. **@babel/preset-typescript**：这是另一个Babel预设，用于支持TypeScript的语法和特性。它允许Babel将TypeScript代码转换为纯JavaScript代码，以便在不支持TypeScript的环境中使用

**webpack.base.js**添加**module.rules**配置

```tsx
// 公共配置
// webpack.base.js
const path = require('path')

module.exports = {
  entry: path.join(__dirname, '../src/main.tsx'), // 入口文件
  output: {
    path: path.join(__dirname, '../dist'), // 打包后的文件存放的地方
    filename: 'static/js/[name].js', // 打包后的文件名
    publicPath: '/' // 打包后的文件的访问路径
    clean: true, // webpack4需要配置clean-webpack-plugin来删除dist文件,webpack5内置了
  },
  module: {
    rules: [
      {
        test: /.(ts|tsx)$/, // 匹配.ts, tsx文件
        use: {
          loader: 'babel-loader',
          options: {
            // 预设执行顺序由右往左(从下到上一步一步处理),所以先处理ts,再处理jsx
            presets: [
              '@babel/preset-react',
              '@babel/preset-typescript'
            ]
          }
        }
      }
    ]
  }
}
```

**配置extensions**

**extensions**是**webpack**的**resolve**解析配置下的选项，在引入模块时不带文件后缀时，会来该配置数组里面依次添加后缀查找文件，因为**ts**不支持引入以 **.ts**, **tsx**为后缀的文件，所以要在**extensions**中配置，而第三方库里面很多引入**js**文件没有带后缀，所以也要配置下**js**

修改**webpack.base.js**，注意把高频出现的文件后缀放在前面

```tsx
// 公共配置
// webpack.base.js
const path = require('path')

module.exports = {
  entry: path.join(__dirname, '../src/main.tsx'), // 入口文件
  output: {
    path: path.join(__dirname, '../dist'), // 打包后的文件存放的地方
    filename: 'static/js/[name].js', // 打包后的文件名
    publicPath: '/' // 打包后的文件的访问路径
    clean: true, // webpack4需要配置clean-webpack-plugin来删除dist文件,webpack5内置了
  },
  module: {
    rules: [
      {
        test: /.(ts|tsx)$/, // 匹配.ts, tsx文件
        use: {
          loader: 'babel-loader',
          options: {
            // 预设执行顺序由右往左(从下到上一步一步处理),所以先处理ts,再处理jsx
            presets: [
              '@babel/preset-react',
              '@babel/preset-typescript'
            ]
          }
        }
      }
    ]
  },
  resolve: {
    extensions: ['.js', '.tsx', '.ts'],
  }
}
```

添加html-webpack-plugin插件

webpack只能处理js文件，要处理html要通过这个插件实现

````bash
npm i html-webpack-plugin -D
````

```tsx
// 公共配置
// webpack.base.js
const path = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  entry: path.join(__dirname, '../src/main.tsx'), // 入口文件
  output: {
    path: path.join(__dirname, '../dist'), // 打包后的文件存放的地方
    filename: 'static/js/[name].js', // 打包后的文件名
    publicPath: '/' // 打包后的文件的访问路径
    clean: true, // webpack4需要配置clean-webpack-plugin来删除dist文件,webpack5内置了
  },
  module: {
    rules: [
      {
        test: /.(ts|tsx)$/, // 匹配.ts, tsx文件
        use: {
          loader: 'babel-loader',
          options: {
            // 预设执行顺序由右往左(从下到上一步一步处理),所以先处理ts,再处理jsx
            presets: [
              '@babel/preset-react',
              '@babel/preset-typescript'
            ]
          }
        }
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname, '../public/index.html'), // 模板取定义root节点的模板
      inject: true, // 自动注入静态资源
    })
  ]
  resolve: {
    extensions: ['.js', '.tsx', '.ts'],
  }
}
```

这就差不多了，其实就是配置了ts，jsx的编译，处理成js，然后编译html，现在啥都没有，这些就够用了

后面在进行一点一点的拓展，现在把这个基础配置，交给其他两个文件，都用的到

#### 2.1webpack开发环境配置

##### 1. 安装 webpack-dev-server

开发环境配置代码在**webpack.dev.js**中,需要借助 [webpack-dev-server](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fwebpack-dev-server)在开发环境启动服务器来辅助开发,还需要依赖[webpack-merge](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fwebpack-merge)来合并基本配置,安装依赖:

```bash
npm i webpack-dev-server webpack-merge -D
```

```js
// webpack.dev.js
const path = require('path')
const { merge } = require('webpack-merge')
const baseConfig = require('./webpack.base.js')

// 合并公共配置,并添加开发环境配置
module.exports = merge(baseConfig, {
  mode: 'development', // 开发模式,打包更加快速,省了代码优化步骤
  devtool: 'eval-cheap-module-source-map', // 源码调试模式,后面会讲
  devServer: {
    port: 3000, // 服务端口号
    compress: false, // gzip压缩,开发环境不开启,提升热更新速度
    hot: true, // 开启热更新，后面会讲react模块热替换具体配置
    historyApiFallback: true, // 解决history路由404问题
    static: {
      directory: path.join(__dirname, "../public"), //托管静态资源public文件夹
    }
  }
})
```

##### 2.package.json添加dev脚本

```json
// package.json
"scripts": {
  "dev": "webpack-dev-server -c build/webpack.dev.js"
},
```

#### 2.1webpack打包环境配置

## 5.搭建一个webpack的React+TS环境的基本流程

### 跑起来

> 1.初始化项目，搭建目录结构
>
> 2.安装，react核心库
>
> 3.编写html模板文件，和入口文件
>
> 4.接下来，就可以开始配webpack了
>
> 5.先配 入口 和 出口
>
> 6.配置loader解析ts和jsx
>
> 7.配置**html-webpack-plugin插件**，这基本简单的环境就没啥问题了
>
> 8.接下来webpack有三个文件，第一个就是刚才的配置，然后有个打包环境，一个开发环境
>
> 9.开发环境配个**webpack-dev-server**，
>
> ```js
> mode: 'development', *// 开发模式,打包更加快速,
> devtool: 'eval-cheap-module-source-map', *// 源码调试模式,后面会讲*
> ```
>
> 10.配打包环境
>
> ```js
> mode: 'production', // 生产模式,会开启tree-shaking和压缩代码,以及其他优化
> ```
>
> 11.配命令
>
> ```js
> "scripts": {
>  "dev": "webpack-dev-server -c build/webpack.dev.js",
>  "build": "webpack -c build/webpack.prod.js"
> }
> ```
>
> 欧克了这就差不多了

### 基础功能

> 1.支持处理css文件  style-loader css-loader
>
> 2.支持处理less文件   less-loader less -D
>
> 3.css兼容性处理   postcss-loader autoprefixer -D  
>
> 4.babel预设处理js兼容   @babel/plugin-proposal-decorators
>
> 5.复制public文件夹   copy-webpack-plugin
>
> 6.处理图片文件      asset-module
>
> 7.处理字体和媒体文件
>
> 8.React热更新    @pmmmwh/react-refresh-webpack-plugin

### 优化构建速度

> 1.构建耗时分析    speed-measure-webpack-plugin -D
>
> 2.开启持久化存储缓存    cache
>
> ```json
> cache: {
>  type: 'filesystem', // 使用文件缓存
> },
> ```
>
> 3. 开启多线程loader    thread-loader -D
> 4. 配置alias别名   减少路径的复杂度
> 5. 缩小loader作用范围     include  解析  exclude  排除
> 6. devtool 配置

### 优化构建结果

> 1.webpack包分析工具     webpack-bundle-analyzer
>
> 2.抽取css样式文件    mini-css-extract-plugin   开发环境使用**style-looader**,打包模式抽离 **mini-css-extract-plugin**
>
> 3.压缩css     css-minimizer-webpack-plugin
>
> 4.压缩js文件   terser-webpack-plugin
>
> 5.打包文件hash的配置
>
> 6.代码分割第三方包和公共模块    splitChunks
>
> 7.tree-shaking清理js     模式**mode**为**production**时就会默认开启**tree-shaking**
>
> 8.tree-shaking清理未使用css      purgecss-webpack-plugin@4 glob-all -D
>
> 9.资源懒加载    react lazy(() => import('@/components/LazyDemo'))  异步组件  
>
> 10.打包时生成gzip文件   减少静态资源文件大小,压缩率在 **70%** 左右     compression-webpack-plugin -D
