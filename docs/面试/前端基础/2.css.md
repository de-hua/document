# CSS（层叠样式表）

## 1. CSS 盒子模型？

### 盒子模型的组成部分

是由 content，padding，border，margin 组成

### 标准盒模型

元素的宽度和高度仅包括内容区域的大小，不包括内边距、边框和外边距。如果需要让元素的总宽度和高度包括内边距和边框，则需要在计算时手动加上这些值

盒子大小 = 内容区域

### IE 盒模型（怪异盒模型）

元素的宽度和高度除了包括内容区域的大小外，还包括内边距和边框。但是，它不包括外边距。这种模型与标准盒模型的主要区别在于宽度和高度的计算方式

盒子大小 = 内容区域+内边距+边框

### 设置盒模型

```css
box-sizing:content-box    // 标准盒模型
box-sizing:border-box 	//怪异盒模型
```

## 2. CSS 所有选择器及其优先级？

### 基本选择器

- **元素选择器**（标签选择器）：根据元素名称选择，如`div`、`p`。
- **类选择器**：选择具有特定类属性的元素，如`.classname`。
- **ID 选择器**：选择具有特定 ID 属性的元素，如`#myid`。ID 在一个文档中应该是唯一的。

**修饰符选择器**

- **后代选择器**（空格分隔）：选择属于某元素后代的元素，如`div p`选择所有在`div`元素内部的`p`元素。
- **子选择器**（`>`）：选择直接子元素，如`div > p`只选择直接位于`div`元素下的`p`元素。
- **相邻选择器**（`+`）：选择紧接在另一元素后的元素，且二者有相同的父元素，如`h1 + p`选择所有紧跟在`h1`元素后的`p`元素。
- **通用兄弟选择器**（`~`）：选择某元素之后的所有兄弟元素，且二者有相同的父元素，如`h1 ~ p`选择所有在`h1`元素之后的`p`元素。

### 优先级

! important > 内联样式 > id 选择器 > 类选择器 > 伪类选择器 > 属性选择器 > 标签选择器 > 通配符选择器（\* 应少用）> 浏览器自定义；

### 各自的权重

通配符选择器 0，0，0，0

元素（类型）选择器 0，0，0，1

类选择器 0，0，1，0

ID 选择器 0，1，0，0

内联样式 1，0，0，0

## 3. css 常用的@规则（at-rules 指令）和使用案例？

### 1.@charset

作用：定义样式表使用的字符集。这通常用于确保样式表中的字符（如文本）能够正确地在不同的浏览器和设备上显示

```
@charset "UTF-8"
```

### 2.@import

导入样式

```
@import url("styles.css");
```

### 3.@font-face

自定义样式

```css
@font-face {
  font-family: 'ui'; /* 自定义字体名称 */
  src: url('./static/text/DOUYINSANSBOLD.OTF') format('opentype'); /* 指定OTF文件路径和格式 */
  font-weight: normal; /* 字体粗细，根据需要设置 */
  font-style: normal; /* 字体风格，根据需要设置 */
}

* {
  font-family: 'ui';
}
```

### 4.@keyframes

定义动画序列

```css
@keyframes example {
  from {
    background-color: red;
  }
  to {
    background-color: yellow;
  }
}
```

### 5.@media

用于定义媒体查询，允许你根据设备的不同特性（如屏幕宽度、分辨率、颜色能力等）应用不同的样式规则。这对于响应式设计非常有用

```css
@media screen and (max-width: 600px) {
  /* 样式规则 */
}
```

## 4.CSS 伪类和伪元素有哪些，它们的区别和实际应用

### 伪类

- `:hover`：鼠标悬停状态。
- `:active`：元素被激活（如鼠标点击）时的状态。
- `:visited`：链接被访问后的状态。
- `:first-child`：选择其父元素的第一个子元素。
- `:nth-child(n)`：选择其父元素的第 n 个子元素。
- `:focus`：元素获得焦点时的状态（如通过键盘导航）。

它们不直接改变元素的结构，而是影响元素在特定条件下的表现样式

### 伪元素

- `::before`：在元素内容之前插入新内容。
- `::after`：在元素内容之后插入新内容。
- `::first-letter`：选择元素的第一个字母进行样式化。
- `::first-line`：选择元素的第一行文本进行样式化。
- `::selection`：选择用户选择的文本并应用样式（注意，`::selection`伪元素在不同浏览器中的支持程度可能有所不同）。

虚拟的“子元素”来实现其功能，这些虚拟元素并不存在于 HTML 文档中，但可以通过 CSS 进行样式化

#### 区别

1. **作用不同**：伪类用于选择元素的特定状态或位置，并根据这些状态或位置来改变样式；伪元素用于在元素的内容前后插入新的内容或选择元素的特定部分进行样式化。
2. **语法不同**：伪类以单个冒号开头，伪元素以双冒号开头
3. **功能不同**：伪类主要影响元素的样式表现，不改变元素结构；伪元素则通过创建虚拟元素来扩展元素的内容或样式。

#### 实际应用

1. 伪类的应用
   - 使用`:hover`伪类来改变鼠标悬停时链接的颜色或背景色，提升用户体验。
   - 使用`:active`伪类来改变按钮被点击时的样式，增强交互感。
   - 使用`:visited`伪类来改变已访问链接的颜色，帮助用户区分已访问和未访问的链接。
2. 伪元素的应用
   - 使用`::before`和`::after`伪元素在元素内容前后插入图标、装饰性文字等，丰富页面元素的表现力。
   - 使用`::first-letter`和`::first-line`伪元素对段落的首字母或首行进行特殊样式处理，如首字下沉或首行缩进。
   - 利用`::selection`伪元素改变用户选择文本时的背景色和字体颜色，提升文本选择的可见性。

## 5.CSS 几种定位的规则、定位参照物、对文档流的影响?

#### 1. 静态定位（Static Positioning）

- **规则**：元素的默认定位方式，不特别设置`position`属性时即为静态定位。静态定位的元素不会受到`top`、`bottom`、`left`、`right`属性的影响。
- **定位参照物**：无特定参照物，元素按照正常的文档流进行布局。
- **对文档流的影响**：不脱离文档流，不影响其他元素的位置。

#### 2. 相对定位（Relative Positioning）

- **规则**：通过设置`position: relative;`，元素相对于其正常位置进行偏移。偏移量由`top`、`bottom`、`left`、`right`属性指定。
- **定位参照物**：元素自身的原始位置。
- **对文档流的影响**：不脱离文档流，但元素的位置会发生变化，同时占据原来的空间，不影响其他元素的位置。

#### 3. 绝对定位（Absolute Positioning）

- **规则**：通过设置`position: absolute;`，元素相对于其最近的已定位（非 static）祖先元素进行定位。如果没有这样的祖先元素，则相对于`<html>`元素（即整个文档）进行定位。
- **定位参照物**：最近的已定位祖先元素或`<html>`元素。
- **对文档流的影响**：脱离文档流，不占据原来的空间，其他元素会填补其原本的空间。

#### 4. 固定定位（Fixed Positioning）

- **规则**：通过设置`position: fixed;`，元素相对于浏览器窗口进行定位，即使页面滚动，元素也会保持在固定位置。
- **定位参照物**：浏览器窗口。
- **对文档流的影响**：脱离文档流，不占据原来的空间，其他元素会填补其原本的空间。

#### 5. 粘性定位（Sticky Positioning）

- **规则**：通过设置`position: sticky;`，元素根据用户的滚动位置在相对定位和固定定位之间切换。当元素在视口内时，它的表现就像`position: relative;`；而当页面滚动使元素滚动到指定偏移位置时，它的表现就像`position: fixed;`，并且相对于其正常流动位置进行定位。
- **定位参照物**：元素的正常流动位置或最近的滚动祖先元素（取决于具体实现）。
- **对文档流的影响**：在粘性定位生效前，元素占据正常空间；生效后，元素脱离文档流，不占据原来的空间。

## 6.雪碧图实现原理?

图片使用 CSS **background**和**background-position**属性渲染

## 7.水平垂直居中的方案并对比它们的优缺点?

### flex

```css
.container {
  display: flex;
  justify-content: center; /* 水平居中 */
  align-items: center; /* 垂直居中 */
  height: 200px; /* 容器高度 */
}

.child {
  /* 子元素样式 */
}
```

### Grid 布局

```css
.container {
  display: grid;
  justify-content: center; /* 水平居中 */
  align-items: center; /* 垂直居中 */
  height: 200px; /* 容器高度 */
}

.child {
  /* 子元素样式 */
}
```

### 绝对定位 + Transform

```css
.container {
  position: relative;
  height: 200px; /* 容器高度 */
}

.child {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
```

## 8.BFC(块级格式上下文)的布局规则，实现原理，可以解决的问题？

### BFC 的布局规则

Web 布局中的一个重要概念，它定义了一个独立的布局区域，在这个区域内的布局不会影响到外部的布局

1. **内部 Box 的垂直放置**：BFC 内部的 Box 会在垂直方向上一个接一个地放置。
2. **Box 边距的重叠**：属于同一个 BFC 的两个相邻 Box 的垂直边距（margin）会发生重叠，且重叠后的边距值以两者中的较大者为准。
3. **BFC 与浮动元素的隔离**：BFC 的区域不会与浮动元素重叠。BFC 内部的浮动元素会被包含在内，并且参与 BFC 的高度计算，从而解决父元素高度塌陷的问题。
4. **元素的左边接触**：每个元素的 margin box 的左边，与包含块 border box 的左边相接触（对于从右到左的格式，则相反）。这意味着 BFC 中的元素会按照正常的文档流进行排列，不会因为内部元素的浮动而改变自身的位置。

### BFC 的实现原理

BFC 的实现原理主要是通过 CSS 中的某些属性来触发元素的 BFC 状态。常见的触发 BFC 的属性包括：

- **float**：元素的 float 属性不是 none。
- **position**：元素的 position 是 absolute 或 fixed。
- **display**：元素的 display 是 inline-block、table-cell、table-caption、flex、inline-flex、grid、inline-grid 等。
- **overflow**：元素的 overflow 不是 visible（除了 overflow:visible 以外的值，如 hidden、auto、scroll 都会创建新的 BFC）。

当元素的这些属性被设置为上述值时，该元素就会成为一个新的 BFC 容器，其内部的布局将遵循 BFC 的布局规则。

### BFC 可以解决的问题

1. **清除浮动带来的高度塌陷问题**：在父元素不设置高度的情况下，如果子元素浮动，父元素的高度可能会塌陷为 0。通过给父元素添加触发 BFC 的属性（如 overflow: hidden），可以使其包含浮动的子元素，从而解决高度塌陷问题。
2. **边距重叠问题**：当相邻元素都设置了垂直方向的 margin 时，这些 margin 可能会重叠，导致最终的边距值并不是预期的。通过将这些元素放在不同的 BFC 中，可以避免边距重叠的问题。
3. **图文环绕问题**：在文本环绕浮动图片的场景中，如果图片外部还有其他元素，可能会受到图片浮动的影响。通过将文本和图片分别放在不同的 BFC 中，可以实现更复杂的布局效果，同时避免布局混乱。
4. **创建隔离的布局环境**：在某些情况下，我们可能希望某个区域的布局与外部布局完全隔离，互不影响。通过创建一个 BFC，可以实现这一需求，使得该区域内的布局不会影响到外部的布局。

## 9.CSS 函数有哪些？

1. **rgba()**
2. **calc()**
3. **min() 和 max()**
4. **clamp()**
5. **translate()**
6. **rotate()**
7. **scale()**
8. **linear-gradient()**
9. **var()**

```css
#p1 {
  background-color: rgba(255, 0, 0, 0.3); /* 半透明的红色背景 */
}

.container {
  width: calc(100% - 20px); /* 容器宽度为父元素宽度的100%减去20px */
}

.responsive-div {
  width: max(50%, 300px); /* 宽度为50%和300px中的较大值 */
  height: min(100vh, 500px); /* 高度为视口高度的100%和500px中的较小值 */
}

.text {
  font-size: clamp(
    1rem,
    2vw,
    3rem
  ); /* 字体大小在1rem到3rem之间，但会根据视口宽度动态调整，最大不超过3rem，最小不低于1rem */
}

.move-down {
  transform: translateY(50px); /* 元素向下移动50px */
}

.rotate-img {
  transform: rotate(45deg); /* 图片顺时针旋转45度 */
}

.zoom-in {
  transform: scale(1.5); /* 元素放大1.5倍 */
}

.gradient-bg {
  background: linear-gradient(
    to right,
    red,
    yellow
  ); /* 从左到右的红色到黄色的渐变背景 */
}

:root {
  --main-color: blue;
}

.text {
  color: var(--main-color); /* 文本颜色为蓝色 */
}
```

## 10.CSS 动画？

需要使用 @keyframes 声明一个动画 animation 接收设置。并且设置参数，执行即可

### 移动动画

```css
@keyframes moveRight {
  from {
    transform: translateX(0);
  }
  to {
    transform: translateX(100px);
  }
}

.move-element {
  animation: moveRight 2s infinite alternate;
}
```

### 旋转动画

```css
@keyframes rotateAnimation {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

.rotate-element {
  animation: rotateAnimation 2s infinite linear;
}
```

### 缩放动画

```css
@keyframes scaleAnimation {
  from {
    transform: scale(1);
  }
  to {
    transform: scale(1.5);
  }
}

.scale-element {
  animation: scaleAnimation 2s infinite alternate;
}
```

### 综合动画

```css
@keyframes complexAnimation {
  from {
    transform: translateX(0) rotate(0deg) scale(1);
  }
  to {
    transform: translateX(100px) rotate(360deg) scale(1.5);
  }
}

.complex-element {
  animation: complexAnimation 4s infinite ease-in-out;
}
```

- `animation`属性接受多个值，如`name duration timing-function delay iteration-count direction fill-mode play-state`，你可以根据需要调整它们。

1. 指定 `@keyframes` 动画的名称
2. 定义动画完成一个周期所需的时间。
3. 定义动画的速度曲线 linear`（匀速）、`ease-in`（加速）、`ease-out`（减速）和 `ease-in-out 先加速后减速
4. 定义动画开始前的延迟时间
5. 定义动画的播放次数
6. 定义动画的播放方向
7. 定义动画在非播放时间（即动画开始前和结束后）的样式。默认值为 `none`，表示动画不会影响元素的样式。
8. 允许你暂停和恢复动画,默认值为 `running`，表示动画正在播放。可以将其设置为 `paused` 来暂停动画
