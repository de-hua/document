# HTML（超文本标记语言）

::: danger
This is a dangerous warning.
:::

## 1.什么是 DOCTYPE， 有何作用？

用于指定当前文档所采用的 HTML 版本

DOCTYPE 声明不是 HTML 标签，而是一种指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令

而且注意，一定要是第一行

```css
<!DOCTYPE html>
```

## 2.说说对 html 语义化的理解？

在没有 CSS 样式情况下也能够让页面呈现出清晰的结构

有利于 SEO 和搜索引擎建立良好的沟通，有助于爬虫抓取更多的有效信息，爬虫是依赖于标签来确定上下文和各个关键字的权重

方便团队开发和维护，语义化更具可读性，遵循 W3C 标准的团队都遵循这个标准，可以减少差异化

## 3.前端页面有哪三层构成，分别是什么？

前端页面主要由三层构成，分别是**结构层**、**表示层**和**行为层**。这三层各自承担着不同的角色和功能，共同构成了用户所看到的网页界面

1. **结构层**

   类似于盖房子的地基，也就是由各种各样的标签，组织和展示这些信息

   结构层是页面的骨架，它包含了用户可以直接看到的所有内容

2. **表示层**

   表示层由 CSS（层叠样式表）负责创建。CSS 用于设置文档的呈现效果，包括颜色、字体、布局、背景等

   表示层决定了网页的外观和样式

3. **行为层**

   行为层由 JavaScript 语言以及 DOM（文档对象模型）主宰。JavaScript 是一种脚本语言，用于实现网页的交互性和动态效果

   行为层负责处理网页上的用户交互和动态行为

## 4.什么是严格模式与混杂模式？

### 严格模式（标准模式）

- **定义**：严格模式是指浏览器按照 W3C 标准（World Wide Web Consortium，万维网联盟）来解析代码。在这种模式下，浏览器会遵循 HTML 和 CSS 的最新标准，以最高标准的排版和 JavaScript 运作模式来渲染页面。
- 特点
  - 遵循最新的 HTML 和 CSS 规范。
  - 提供更严格的错误检查和处理。
  - 渲染效果更加统一和可预测。
  - 有助于提升网页的兼容性和可访问性。

### 混杂模式（怪异模式或兼容模式）

- **定义**：混杂模式是指浏览器用自己的方式（通常是模拟老式浏览器的行为）来解析代码。在这种模式下，浏览器会以宽松的向后兼容的方式来显示页面，以便老式的网站能够继续工作。
- 特点
  - 不严格遵循 HTML 和 CSS 规范。
  - 渲染效果可能因浏览器而异，导致页面在不同浏览器中的表现不一致。
  - 允许一些过时的 HTML 和 CSS 语法，以便兼容老旧的网站。
  - 可能导致一些现代 Web 技术（如 HTML5 和 CSS3）无法正常工作或表现异常。

### 触发条件（浏览器会根据 DOCTYPE 声明的存在和类型来判断是否采用严格模式。）

- 严格模式
  - HTML 文档包含严格的 DOCTYPE 声明，如`<!DOCTYPE html>`）
- 混杂模式
  - HTML 文档不包含 DOCTYPE 声明，或者 DOCTYPE 声明不正确、不完整。

## 5.对于 Web 标准以及 W3C 的理解？

`Web标准`简单来说可以分为结构、表现、行为。

其中结构是由 HTML 各种标签组成，简单来说就是 body 里面写入标签是为了页面的结构。

表现指的是 CSS 层叠样式表，通过 CSS 可以让我们的页面结构标签更具美感。

行为指的是页面和用户具有一定的交互，这部分主要由 JS 组成

`W3C`，也叫万维网联盟，标准包括 HTML、CSS、ECMAScript 等等，web 标准的制定有很多好处，比如说：

- 学习成本降低，只需要学习标准就行，否则就要学习各个浏览器厂商标准

## 6.行级元素和块级元素分别有哪些及怎么转换？

### 转换

```css
display: inline; //转行内
display: inline-block; //转行内块
display: block; //转块
```

### 块级元素

块级元素会**独占一行**，其宽度默认是容器的 100%，即一块区域，可以通过 CSS 设置宽高、内外边距等。常见的块级元素包括：

```css
p、div、form、ul、li、ol、table、h1~h6、tr、td、th、tbody、thead、tfoot
```

### 行级元素

行级元素的特点是不会独占一行，其宽度和高度由内容决定，不能通过 CSS 直接设置

> ​ 注意
>
> - 行内元素设置宽度`width`无效
> - 行内元素设置`height`无效，但是可以通过`line-height`来设置
> - 设置`margin`只有左右有效，上下无效
> - 设置`padding`只有左右有效，上下无效

```css
span、a、img、button、input、select
```

行内块元素

行内块元素既具有行级元素的特性（不会独占一行），又具有块级元素的特性（可以设置宽高）。常见的行内块元素包括：

```css
img,button
```

## 7.H5 有哪些新元素和新特性

1. 语义化标签，如：article、footer、header、nav 等
2. 视频 video、音频 audio
3. 画布 canvas
4. 本地离线存储，localStorage 长期存储数据，浏览器关闭后数据不丢失，sessionStorage 的数据在浏览器关闭
5. 表单控件，time、email
6. 拖拽

## 8.如何使用 HTML5 中的 Canvas 元素绘制图形？

简单画一个矩形

```html
<canvas id="myCanvas" width="200" height="200"></canvas>
<script>
  var canvas = document.getElementById('myCanvas')
  var ctx = canvas.getContext('2d')
  ctx.fillStyle = 'red'
  ctx.fillRect(50, 50, 100, 100)
</script>
```

在这个示例中，使用 `document.getElementById()` 方法获取 `Canvas` 元素，

`getContext(“2d”)` 获取 2D 绘图上下文。

使用 `fillStyle` 属性设置填充颜色，`fillRect()` 方法绘制一个矩形。

## 9. cookie、sessionStorage 和 localStorage 的区别

|                                                    | cookie                                               | localStorage | sessionStorage |
| -------------------------------------------------- | ---------------------------------------------------- | ------------ | -------------- |
| 由谁初始化                                         | 客户端或服务器，服务器可以使用 `Set-Cookie` 请求头。 | 客户端       | 客户端         |
| 过期时间                                           | 手动设置                                             | 永不过期     | 当前页面关闭时 |
| 在当前浏览器会话（browser sessions）中是否保持不变 | 取决于是否设置了过期时间                             | 是           | 否             |
| 是否随着每个 HTTP 请求发送给服务器                 | 是，Cookies 会通过 `Cookie` 请求头，自动发送给服务器 | 否           | 否             |
| 容量（每个域名）                                   | 4kb                                                  | 5MB          | 5MB            |
| 访问权限                                           | 任意窗口                                             | 任意窗口     | 当前页面窗口   |

### 1.存储数据的生命周期

1. **Cookie**的生命周期由开发者设置，可以设置过期时间（expires）或最大存活时间（max-age），如果未设置，则默认在浏览器会话结束时失效（即关闭浏览器后）
2. **sessionStorage**：sessionStorage 的生命周期仅限于当前浏览器会话（标签页或窗口）。一旦浏览器窗口或标签页被关闭，存储在 sessionStorage 中的数据就会被清除。
3. **localStorage**：localStorage 的生命周期非常长，除非用户手动清除，或者浏览器出于安全考虑（如存储空间不足）自动清除，否则数据将一直存储在用户的浏览器中。

### 2.存储大小

1. **Cookie**：由于 Cookie 会随着 HTTP 请求发送到服务器，因此其大小受到限制，以避免对性能产生太大影响。一般来说，单个 Cookie 的大小限制在 4KB 左右，整个域名下的 Cookie 总数和总大小也有限制。
2. **sessionStorage** 和 **localStorage**：这两者的存储容量相对较大，通常可以达到 5MB 或更高（具体取决于浏览器实现）。这使得它们能够存储更多的数据，如用户设置、缓存数据等。

### 3.与服务器端的通信

- **Cookie**：Cookie 会在浏览器和服务器之间传递，每次 HTTP 请求都会携带 Cookie 信息（除非设置了 Cookie 的 HttpOnly 属性，该属性会阻止客户端 JavaScript 访问 Cookie）。这使得 Cookie 成为实现会话跟踪、用户身份验证等功能的常用手段。
- **sessionStorage** 和 **localStorage**：这两种存储方式都是纯客户端的，不会与服务器进行通信。它们的数据存储在用户的浏览器中，只有在用户访问该网站时才能被访问和修改。

### 4.数据的共享性

- **Cookie**：在同一浏览器下，不同标签页或窗口可以共享同一个域名下的 Cookie（这取决于 Cookie 的 Path 和 Domain 属性）。
- **sessionStorage**：仅在当前浏览器标签页或窗口中有效，不同标签页或窗口之间无法共享数据。
- **localStorage**：在同一浏览器下，所有标签页和窗口都可以共享同一个域名下的 localStorage 数据。

## 10.script、script async 和 script defer 的区别?

```html
<script>、<script async> 和 <script defer> 三者在HTML中用于引入JavaScript代码，但它们之间存在显著的区别，主要体现在脚本的加载和执行方式上。
```

> ### 1. `<script>`
>
> - **加载与执行**：`<script>` 标签默认是同步加载并阻塞 HTML 解析的。这意味着浏览器在解析到 `<script>` 标签时会立即停止解析 HTML 文档，等待脚本加载并执行完毕后，再继续解析 HTML 文档。如果脚本文件较大或网络状况不佳，这会导致页面渲染的延迟。
> - **应用场景**：适用于脚本体积较小，且对页面渲染顺序有严格要求的情况。
>
> ### 2. `<script async>`
>
> - **加载与执行**：`<script async>` 标签允许脚本异步加载，即脚本的加载与 HTML 的解析是并行的，不会阻塞 HTML 的解析。但是，脚本的执行时机是不确定的，一旦脚本加载完成，它就会立即执行，而不考虑脚本在 HTML 文档中的位置。这可能会导致脚本执行时 DOM 元素还未完全加载完成，从而引发错误。
> - **应用场景**：适用于那些不依赖 DOM 元素，或者即使 DOM 元素未完全加载也不会引发错误的独立脚本。
>
> ### 3. `<script defer>`
>
> - **加载与执行**：`<script defer>` 标签也是异步加载脚本，但与 `<script async>` 不同的是，`defer` 脚本会等到整个 HTML 文档解析完成后，再按照它们在 HTML 文档中出现的顺序依次执行。这意味着，即使脚本加载完成，它也不会立即执行，而是等待所有 DOM 元素加载完成后再执行，从而保证了脚本执行时 DOM 的完整性。
> - **应用场景**：适用于那些依赖于 DOM 元素，且需要确保 DOM 完全加载后再执行的脚本。

|                   | `<script>`                           | `<script async>`                             | `<script defer>`                              |
| ----------------- | ------------------------------------ | -------------------------------------------- | --------------------------------------------- |
| **加载方式**      | 同步加载，阻塞 HTML 解析             | 异步加载，与 HTML 解析并行                   | 异步加载，与 HTML 解析并行                    |
| **执行时机**      | 立即执行，阻塞后续内容               | 加载完成后立即执行，不考虑 HTML 文档解析进度 | HTML 文档解析完成后，按在文档中的顺序依次执行 |
| **对 DOM 的依赖** | 可能在执行时 DOM 未完全加载          | 可能在执行时 DOM 未完全加载                  | 确保执行时 DOM 已完全加载                     |
| **应用场景**      | 脚本体积小，对页面渲染顺序有严格要求 | 独立脚本，不依赖 DOM 元素                    |                                               |

## 11.iframe 的作用以及优缺点

### iframe 的优缺点

#### 优点

1. **独立性**：iframe 可以在页面上独立显示一个页面或内容，不会与页面其他元素产生冲突。
2. **重用性**：iframe 可以在多个页面中重用同一个页面或内容，减少代码的冗余。
3. **异步加载**：iframe 的加载是异步的，页面可以在不等待 iframe 加载完成的情况下进行展示。
4. **跨域访问**：使用 iframe 可以方便地实现跨域访问，这在某些场景下非常有用。

#### 缺点

1. **管理复杂**：iframe 会产生很多页面，增加了管理的复杂性。
2. **搜索引擎优化（SEO）问题**：iframe 框架的内容无法被搜索引擎有效捕获，这可能会影响页面的搜索排名。
3. **兼容性差**：iframe 的兼容性相对较差，可能在不同浏览器或设备上表现不一致。
4. **安全风险**：iframe 可以嵌入来自其他网站的内容，这可能会带来安全风险，如点击劫持等攻击。
5. **性能影响**：iframe 中的内容需要额外的 HTTP 请求和页面加载时间，可能会影响整个页面的加载速度。
6. **可访问性问题**：有些屏幕阅读器可能无法正确读取 iframe 中的内容，影响网站的可访问性。

### 使用

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body>
    <div>我是页面</div>
    <iframe
      src="https://juejin.cn/post/7316349850855211046#heading-6://www.example.com"
      width="600"
      height="400"
    >
    </iframe>
    <button>按钮</button>
  </body>
</html>
```

## 12.Quirks（怪癖）模式是什么？它和 Standards（标准）有什么区别？

|                | Quirks 模式                               | Standards 模式                       |
| -------------- | ----------------------------------------- | ------------------------------------ |
| **目的**       | 为了与旧版本的 HTML 文档兼容              | 遵循 HTML5 和现代 Web 标准           |
| **盒模型**     | IE 浏览器宽度和高度包含 padding 和 border | 标准盒模型，边距和填充不影响实际大小 |
| **浮动和定位** | 行为可能与标准模式不同                    | 行为更一致，容易控制                 |
| **垂直对齐**   | 可能不一致，需要额外样式修复              | 行为更一致                           |
| **默认字体**   | 可能使用不同默认字体                      | 使用相同默认字体                     |

### 触发方式

这两种模式的触发方式通常是通过文档类型（DOCTYPE）声明来确定的。如果没有指定文档类型或使用了旧的文档类型，浏览器可能会进入 Quirks 模式。而使用现代的文档类型声明，如`<!DOCTYPE html>`，则浏览器会进入 Standards 模式

## 13.meta viewport 是做什么用的，怎么写？

Viewport，适配移动端，可以控制视口的大小和比例：

```html
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, maximum-scale=1 user-scalable=no"
/>
```

width viewport ：宽度(数值/device-width)

height viewport ：高度(数值/device-height)

initial-scale ：初始缩放比例

maximum-scale ：最大缩放比例

minimum-scale ：最小缩放比例

user-scalable ：是否允许用户缩放(yes/no）

## 14.浏览器渲染原理？

### 第一步 解析 html（Document Object Model Tree）

构建出 DOM 树

### 第二步 解析 css (CSS Object Model Tree)

构建出 CSSOM 树

### 第三步 有可能遇到 JS

遇到 JS 的 script 标签时必须暂停一切行为，等待下载 JS 文件

因为 可能会 修改 DOM 修改 CSSOM

### 第四步 构建渲染树 （Render Tree）

通过遍历 DOM 树，为每一个 DOM 节点，计算它的**所有** CSS 属性

### 第五步 布局 （Layout ）

构建出布局树，浏览器计算每个渲染节点计算位置和尺寸

### 第六步 分层 （Layering）

根据布局树生成分层树，将布局树中的元素分解为多个层 可以提高绘制和重新绘制性能 z-index`，`opacity`，`transform

### 第七步 绘制 （Painting）

根据分层树进行生成绘制步骤复合图层

转像素，分为多个绘制阶段包括 颜色、边框、阴影、背景图片

### 第八步 分块（Tiling）

浏览器提高渲染效率 ，会把页面分成多个图块，并行处理不同区域的渲染任务，加快渲染速度

会优先画出视口内以及接近视口的内容

### 第九步 光栅化 （Rasterization）

光栅化将每个图块变成位图，既然上一步已经分块了，这一步自然是优先处理接近视口的块。

位图：可以简单理解成用二维数组存储的像素信息。

### 第 10 步合成（Compositing）

计算出每个位图在屏幕上的位置，交给 GPU 进行最终呈现

### 第 11 步 显示 （Display）

图像数据会从 GPU 的显存中读取，然后就可以看到了

![image-20240829161531433](../../public/image-20240829161531433.png)

## 15.重排和重绘的区别？

### 重绘（Repaint）

影响元素外观，不影响布局会触发重绘

比如：修改了 元素颜色，背景颜色，阴影

**示例：**

- 修改元素的 `color`、`background-color`、`visibility` 等。
- 设置 `border-color`、`box-shadow` 等属性。

**特点：**

- 重绘不会引发布局变化，所以它的性能开销相对较小。

### 重排（Reflow）

重排，也称为回流，是指当页面布局发生变化时，浏览器需要重新计算文档的布局

重排会影响到页面上部分甚至全部的元素位置和大小。

**示例：**

- 添加或删除 DOM 元素。
- 修改元素的尺寸（如 `width`、`height`、`padding`、`margin`）。
- 修改字体大小、显示属性（如 `display: none` -> `display: block`）等。
- 浏览器窗口的大小变化，导致整个页面的布局需要重新计算。

**特点：**

- 重排的代价通常比重绘高，因为它不仅要重新计算受影响元素的几何属性，还可能影响其后代和兄弟元素。
- 在大型文档或复杂布局中，频繁的重排可能会严重影响性能。

### **重绘与重排的关系**

- **重排通常会引发重绘**：因为元素的位置或大小发生了变化，浏览器需要重新绘制页面的某些部分。但反过来，重绘并不一定会引发重排。
- **性能影响**：重排比重绘的性能影响大得多，尤其是在复杂的页面结构或大型文档中。因此，在优化页面性能时，应该尽量减少引发重排的操作。

### **总结**

- **重绘**：只涉及外观改变的更新，不影响布局，性能开销相对较小。
- **重排**：涉及布局的重新计算，影响更大，性能开销较大。
