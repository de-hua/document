# 组件基础

## 一 React合成事件？React 事件机制？

它不同于原生 DOM 事件。React 之所以引入合成事件，主要是为了解决跨浏览器兼容性问题，同时提供了一种更高效的方式来处理事件

可以理解成 JSX 上写的事件并没有绑定在对应的真实 DOM 上，而是通过事件代理的方式，将所有的事件都统一绑定在了 `document` 上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。

实现合成事件的目的如下：

- 合成事件首先抹平了浏览器之间的兼容问题，另外这是一个跨浏览器原生事件包装器，赋予了跨浏览器开发的能力；
- 对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。

### 为什么使用合成事件呢？

React 之所以引入合成事件，主要是为了解决**跨浏览器兼容性问题**，并且还**性能优化**

1. 不同的浏览器对 DOM 事件的实现存在差异，比如事件对象的属性、事件冒泡和捕获的行为等。React 通过合成事件层封装了这些差异，使得开发者可以编写一致的事件处理代码，而无需担心浏览器兼容性问题。
2. React 的合成事件系统通过事件池（Event Pooling）机制来优化性能。在 React 16 之前的版本中，事件对象在事件处理函数执行完毕后会被销毁，以避免内存泄漏。但是，在 React 16 及以后的版本中，引入了事件池的概念，即 React 会重用事件对象，而不是每次都创建新的对象。这样做可以减少内存分配和垃圾回收的开销，提高应用的性能。

### 合成事件是什么？

React 16.x及以前的合成事件：

1. 事件委托到document；
2. 存在React事件和原生事件的映射关系，比如onMouseLeave会映射成原生的mouseout事件；
3. 事件池机制,在React 16及之前的版本中，React使用了一个称为“事件池”的机制来优化内存使用。这意味着React会重用事件对象，而不是每次事件触发时都创建一个新的对象

React 17后的合成事件：

1. 事件委托到root；
2. React capture阶段的合成事件提前到原生事件capture阶段执行；
3. 移除事件池机制,从React 17开始，这个机制被移除了，因为现代JavaScript引擎的垃圾回收机制已经足够高效，不再需要这种额外的优化

### 阻止事件冒泡？

````
 event.stopPropagation(); // 阻止事件冒泡  
````

## 二 对React-Fiber的理解，它解决了什么问题？

### Fiber解决的问题？

React V15 在渲染时，会递归比对 VirtualDOM 树，找出需要变动的节点，然后同步更新它们。这个过程期间， React 会占据浏览器资源，这会导致用户触发的事件得不到响应，并且会导致掉帧，**导致用户感觉到卡顿**。

### Fiber

Fiber架构的引入正是为了解决这一问题，它通过将渲染过程（渲染，布局，绘制，资源加载）分割成多个小的可中断的任务（即“fiber”），实现了更加灵活和高效的渲染调度。Fiber架构的核心在于引入了“工作循环”（work loop）和“调度器”（scheduler）的概念，使得React可以在渲染过程中适时地让出CPU执行权，允许浏览器处理其他高优先级任务，如用户的输入事件、动画等。

### Fiber好处

1. **提升用户体验**：通过将渲染任务分割成多个小的可中断的单元，Fiber允许React在渲染过程中适时地让出CPU执行权，从而减少了长时间占用UI线程的情况，提升了应用的响应性和流畅度。
2. **优化性能**：Fiber架构允许React在渲染过程中进行优先级排序，优先处理用户交互相关的高优先级任务，如点击事件、滚动事件等，从而提升了应用的性能和用户体验。
3. **更好的错误处理和恢复能力**：Fiber架构的引入还使得React在渲染过程中能够更好地处理错误和异常情况，当遇到错误时，Fiber可以停止当前任务并回滚到安全的状态，而不会影响到整个应用的稳定性。
4. **支持并发模式**：Fiber架构为React的并发模式提供了基础，使得React在未来能够更好地支持异步渲染和流式数据等现代Web开发中的常见需求。

## 三 React中什么是受控组件和非控组件？

一句话说明白 **表单元素值由react状态所掌控**就是受控组件

那么相反  **表单元素的值由DOM元素自身管理**就是非受控组件

**受控组件场景**

- 当需要对用户输入进行实时验证和处理时。
- 当需要确保表单元素的值与React应用的状态保持同步时

**非受控组件场景**

- 当不需要对表单元素的值进行实时操作或验证时。
- 当只需要在表单提交时获取表单的最终值进行处理时。

## 四 React中useRef的作用是什么？有哪些应用场景？

主要作用就是为了获取DOM元素

应用场景

- 处理焦点、文本选择或者媒体的控制
- 触发必要的动画

## 五 React的状态提升是什么？使用场景有哪些？

**将多个组件需要共享的状态提升到它们最近的父组件上**，**在父组件上改变这个状态然后通过props分发给子组件**

## 六 React的组件通信方式

父子组件通信  使用 porps

子父通信使用  自定义函数

跨组件传递    使用  context

### 父子组件通信可以使用 props

```tsx
import React, { useState } from 'react';  
import ChildComponent from './ChildComponent';  
  
function ParentComponent() {  
  // 父组件的状态  
  const [data, setData] = useState('Initial data');  
  
  // 父组件的“方法”，用于更新状态  
  const updateData = (newData) => {  
    setData(newData);  
  };  
  
  return (  
    <div>  
      <h1>Parent Component</h1>  
      <p>Data from Parent: {data}</p>  
      {/* 将数据和更新数据的函数作为props传递给子组件 */}  
      <ChildComponent data={data} updateData={updateData} />  
    </div>  
  );  
}  
  
export default ParentComponent;
```

```tsx
import React from 'react';  
  
function ChildComponent({ data, updateData }) {  
  // 子组件可以直接访问来自父组件的props  
  return (  
    <div>  
      <h2>Child Component</h2>  
      <p>Data from Parent (via props): {data}</p>  
      {/* 调用父组件的“方法”来更新数据 */}  
      <button onClick={() => updateData('Updated data from Child')}>  
        Update Data in Parent  
      </button>  
    </div>  
  );  
}  
  
export default ChildComponent;
```

### 父子组件通信可以使用 props

```tsx
import React from 'react';  
  
function ChildComponent({ onSendData }) {  
  const handleSend = () => {  
    // 准备要发送的数据  
    const dataToSend = 'Data from Child';  
    // 调用父组件传递的回调函数，并发送数据  
    onSendData(dataToSend);  
  };  
  
  return (  
    <div>  
      <h2>Child Component</h2>  
      <button onClick={handleSend}>Send Data to Parent</button>  
    </div>  
  );  
}  
  
export default ChildComponent;
```

```tsx
import React, { useState } from 'react';  
import ChildComponent from './ChildComponent';  
  
function ParentComponent() {  
  // 父组件的状态  
  const [receivedData, setReceivedData] = useState('');  
  
  // 父组件的回调函数，用于接收来自子组件的数据  
  const onSendData = (data) => {  
    // 处理接收到的数据，例如更新状态  
    setReceivedData(data);  
  };  
  
  return (  
    <div>  
      <h1>Parent Component</h1>  
      <p>Data Received from Child: {receivedData}</p>  
      {/* 将回调函数作为props传递给子组件 */}  
      <ChildComponent onSendData={onSendData} />  
    </div>  
  );  
}  
  
export default ParentComponent;
```

跨层传递

```tsx
import React, { createContext, useContext, useState } from 'react'

// 不需要写在组件里面，直接写在组件外面
const nameContext = createContext("我是一层一层下来的数据啊")

export default function App () {
  const [name, setName] = useState("张三")
  return (
    <nameContext.Provider value={{
      name,
      setName
    }}>
      <div>
        APP
        <Bpp></Bpp>
      </div>
    </nameContext.Provider>
  )
}
function Bpp () {
  const name = useContext(nameContext)
  const changeName = () => {
    name.setName("李四")
  }
  return (
    <div>
      BPP
      <button onClick={changeName} >修改数据</button>
      <Cpp></Cpp>
    </div>
  )
}
function Cpp () {
  // 消费
  const name = useContext(nameContext)
  return (
    <div>
      CPP
      {name.name}
    </div>
  )
}
```

## 七 什么是副作用？

副作用可以理解成

副作用指的是那些除了返回函数值之外，还对程序状态或世界产生影响的操作。这些操作包括但不限于：

- 修改浏览器的 DOM
- 设置定时器（`setTimeout`, `setInterval`）
- 发起网络请求

## 八 useSelector的作用？原理？

> 1. Redux             状态仓库
> 2. React-redux    用于连接React和仓库之间的中间件

### 作用

它是react-redux库中的一个方法，它的作用是读取redux store中的某一段数据，更新hooks react组件

### 原理

## 九 useMemo，React.memo  ，useCallback  这三个钩子的作用  怎么配合优化？

> **memo 是防止 props 没变时的重新渲染，**
>
> **useMemo 和 useCallback 是防止 props 的不必要变化**

### 解决问题

主要是为了避免不必要的渲染

### 假设1  memo

#### 父组件

父组件内部定时器，频繁修改自身状态，传递给子组件一个数子 2

```tsx
import { memo, useEffect, useState } from 'react'
import Bbb from './Bpp'

function Aaa() {
  const [num, setNum] = useState(1)

  // 父组件随机数
  useEffect(() => {
    setInterval(() => {
      setNum(Math.random())
    }, 2000)
  }, [])

  return (
    <div>
      <Bbb count={2}></Bbb>
    </div>
  )
}

export default Aaa

```

#### 子组件

子组件什么也不做，只接收父组件传递过来的数据

```tsx
interface BbbProps {
  count: number
}

export default function Bbb(props: BbbProps) {
  console.log('bbb render')
  return <h2>{props.count}</h2>
}
```

#### 发现问题

**子组件频繁渲染**

> 父组件修改自己的状态，传递给子组件的只是一个数字，
>
> 按照逻辑父组件传递的数据没有改变 ，子组件也没有做什么操作，按照逻辑子组件不应该在次渲染的

修改子组件即可，使用memo包裹子组件即可

```tsx
import { memo } from 'react'

interface BbbProps {
  count: number
}

function Bbb(props: BbbProps) {
  console.log('bbb render')
  return <h2>{props.count}</h2>
}

export default memo(Bbb) 
```

### 假设2   useCallback

基于上一次的组件,父组件在给子组件传递一个方法

#### 父组件

```tsx
import { memo, useEffect, useState } from 'react'
import Bbb from './Bpp'

function Aaa() {
  const [num, setNum] = useState(1)

  const [count, setCount] = useState(2)

  // 父组件随机数
  useEffect(() => {
    setInterval(() => {
      setNum(Math.random())
    }, 2000)
  }, [])

  const bbbCallBack = () => {
    console.log('传递的方法')
  }

  console.log('父组件执行')
  return (
    <div>
      <Bbb count={count} bbbCallBack={bbbCallBack}></Bbb>
    </div>
  )
}

export default Aaa
```

#### 子组件

```tsx
import { memo } from 'react'

interface BbbProps {
  count: number
  bbbCallBack: () => void
}

function Bbb(props: BbbProps) {
  console.log('bbb render')
  return <h2>{props.count}</h2>
}

export default memo(Bbb)
```

#### 发现问题

子组件的memo失效了

> 父组件只是给子组件传递了一个函数，就生效了
>
> 因为每次 **方法都是新创建的**，也就是每次 **props 都会变**，这样 memo 就没用了

把父组件传递给子组件的方法包裹起来就可以了

```tsx
import { memo, useEffect, useState, useCallback } from 'react'
import Bbb from './Bpp'

function Aaa() {
  const [num, setNum] = useState(1)

  const [count, setCount] = useState(2)

  // 父组件随机数
  useEffect(() => {
    setInterval(() => {
      setNum(Math.random())
    }, 2000)
  }, [])

  const bbbCallBack = useCallback(() => {
    console.log('传递的方法')
  }, [])

  console.log('父组件执行')
  return (
    <div>
      <Bbb count={count} bbbCallBack={bbbCallBack}></Bbb>
    </div>
  )
}

export default Aaa
```

> 它的作用就是当**依赖项数组不变**的时候，**始终返回同一个 function**，当 依赖项数组变的时候，才把 function 改为新传入的。
>
> 这时候你会发现，memo 又生效了

### 假设3   useMemo  

基于上一次的组件,父组件在给子组件传递一个对象

#### 父组件

```tsx
import { memo, useEffect, useState, useCallback } from 'react'
import Bbb from './Bpp'

function Aaa() {
  const [num, setNum] = useState(1)

  // 父组件随机数
  useEffect(() => {
    setInterval(() => {
      setNum(Math.random())
    }, 2000)
  }, [])

  const bbbCallBack = useCallback(() => {
    console.log('传递的方法')
  }, [])

  console.log('父组件执行')

  const count = {
    age: 12,
    name: '张三',
  }

  return (
    <div>
      <Bbb count={count} bbbCallBack={bbbCallBack}></Bbb>
    </div>
  )
}

export default Aaa
```

#### 子组件

```tsx
import { memo } from 'react'

interface BbbProps {
  count: {
    age: number
    name: string
  }
  bbbCallBack: () => void
}

function Bbb(props: BbbProps) {
  console.log('bbb render')
  return (
    <>
      <h2>{props.count.age}</h2>
      <h2>{props.count.name}</h2>
    </>
  )
}

export default memo(Bbb)
```

#### 发现问题

子组件的memo失效了

> 父组件只是给子组件传递了一个对象数据，就失效了
>
> 因为每次**值都是新创建的**，也就是每次 **props 都会变**，这样 memo 就没用了

把父组件传递给子组件的方法包裹起来就可以了

```tsx
import { memo, useEffect, useState, useCallback, useMemo } from 'react'
import Bbb from './Bpp'

function Aaa() {
  const [num, setNum] = useState(1)

  const [count, setCount] = useState({
    age: 12,
    name: '张三',
  })

  // 父组件随机数
  useEffect(() => {
    setInterval(() => {
      setNum(Math.random())
    }, 2000)
  }, [])

  const bbbCallBack = useCallback(() => {
    console.log('传递的方法')
  }, [])

  console.log('父组件执行')

  const count2 = useMemo(() => {
    return count
  }, [])

  return (
    <div>
      <Bbb count={count2} bbbCallBack={bbbCallBack}></Bbb>
    </div>
  )
}

export default Aaa
```
