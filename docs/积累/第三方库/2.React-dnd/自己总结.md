# 介绍

[React DnD (react-dnd.github.io)](https://react-dnd.github.io/react-dnd/about)  业务文档

有三个非常重要的api，了解这三个，基本上遇到日常的拖拽，没有问题

这三个不够用完成不了需求，可以在了解

```bash
npm create vite@latest   //选  React 和 TypeScript
npm i  //安装依赖
npm install react-dnd react-dnd-html5-backend   //拖拽依赖
```

这是我现在依赖的版本

```json
{
  "name": "vite-project",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite  --port 8081 ",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.3.1",
    "react-dnd": "^16.0.1",
    "react-dnd-html5-backend": "^16.0.1",
    "react-dom": "^18.3.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.0",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.1",
    "eslint": "^9.9.0",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.9",
    "globals": "^15.9.0",
    "typescript": "^5.5.3",
    "typescript-eslint": "^8.0.1",
    "vite": "^5.4.1"
  }
}
```

## DndProvider 

::: tip    这是干嘛的呢

必填项backend，通过它将其注入后端，可以使用React-dnd随附的HTML5后端，除了自定义React-dnd后端代码。

::: 

```tsx
import { DndProvider } from 'react-dnd' //核心库
import { HTML5Backend } from 'react-dnd-html5-backend' //核心库
import { createRoot } from 'react-dom/client'
import App from './App.tsx'
import './index.css'

createRoot(document.getElementById('root')!).render(
  <DndProvider backend={HTML5Backend}>
    <App />
  </DndProvider>
)
```

解释

1. 包裹要进行拖拽的组件
2. 要传递一个backend的属性值
   1. HTML5Backend  是web使用的
   2. TouchBackend    移动端使用的

欧克了接下来，修改我们的App组件  我们创建两个组件

一个用于接收拖拽元素的容器     **Container.tsx** 

一个用于存放要拖拽的元素          **Box.tsx**

```tsx
// App.tsx 组件

import Box from './page/Box/index'
import Container from './page/Container/index'
function App() {
  return (
    <>
      <div className="page">
        <Container />
        <Box />
      </div>
    </>
  )
}

export default App
```

```css
// index.css 样式文件

.page {
  width: 100vw;
  height: 100vh;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}
```

```tsx
//page/Container/index.tsx  组件

import style from './index.module.css'

export default function index() {
  return (
    <>
      <div className={style.page}>拖拽存放区域</div>
    </>
  )
}
```

```css
//page/Container/index.module.css  样式文件

.page {
  width: 800px;
  height: 500px;
  border: 1px solid #000;
}
```

```tsx
//page/Box/index.tsx  组件

import style from './index.module.css'

export default function index() {
  return (
    <>
      <div className={style.page}>可拖拽区域</div>
    </>
  )
}
```

```css
//page/Box/index.module.css  样式文件

.page {
  width: 800px;
  height: 300px;
  border: 1px solid #000;
  margin-top: 50px;
}

```

好了看一下页面



页面现在是这样的，准备工作就可以了

## useDrag

::: tip    这是干嘛的呢

这个是一个非常重要的api，让我们的DOM可以实现拖动的

**useDrag的返回值**

> ​	useDrag返回三个参数
>
> 1. **第一个返回值是一个对象** : 表示关联在拖拽过程中的变量，需要在传入useDrag的规范方法的collect属性中进行映射绑定,比如：isDraging,canDrag等（其中包含从collect函数收集的属性。如果collect未定义函数，则返回一个空对象）
> 2. **第二个返回值**: 代表可以拖拽   (拖动源的连接器功能，把Dom的ref传进去就可以)
> 3. **第三个返回值** :代表拖拽元素拖拽后实际操作到的dom  (DOM的预览部分)

**useDrag传入的参数**

> item: 必填。一个普通的JavaScript对象，描述了要拖动的数据。这是可用于放置目标的有关拖动源的唯一信息
>
> type: 必填，并且必须是字符串，ES6符号。只有注册为相同类型的放置目标才会对此项目做出反应
>
> previewOptions: 选填。描述拖动预览选项的普通JavaScript对象
>
> options: 选填，一个普通的对象。如果组件的某些道具不是标量的（即不是原始值或函数），则arePropsEqual(props, otherProps)在options对象内部指定自定义函数可以提高性能。除非您有性能问题，否则不要担心。
>
> begin(monitor)：选填，拖动操作开始时触发。不需要返回任何内容，但是如果返回对象，它将覆盖item规范的默认属性。
>
> end(item, monitor)：选填，拖动停止的时候，end将会被调用。
>
> canDrag(monitor)：选填。使用它可以指定当前是否允许拖动。默认允许
>
> isDragging(monitor)：选填。默认情况下，只有启动拖动操作的拖动源才被视为拖动
>
> collect：选填，收集功能

看着这么多，其实普通的只需要 itme 和type  就够用了

::: 

试一下把

接下来要处理Box组件的内容

```
import style from './index.module.css'
import { useRef } from 'react'

import { useDrag } from 'react-dnd'

export default function index() {
  const redRef = useRef(null)
  const [, drag] = useDrag({
    type: 'box', //类型
    item: {
      type: 'blue', //代表自己的描述
      id: '1',
    },
  })

  drag(redRef) //传入ref实现拖拽

  return (
    <>
      <div className={style.page}>
        可拖拽区域
        <div ref={redRef} className={style.red}>
          红色
        </div>
      </div>
    </>
  )
}

```

```tsx
.page {
  width: 800px;
  height: 300px;
  border: 1px solid #000;
  margin-top: 50px;
}
.red {
  background-color: red;
  width: 100px;
  height: 100px;
}

```

写完这个，就发现可以拖动了

但是拖不进去，因为存放区域还没有实现呢