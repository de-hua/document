# 介绍

- 使用 useDrag 处理拖拽的元素，使用 useDrop 处理 drop 的元素，使用 useDragLayer 处理自定义预览元素
- 在根组件使用 DndProvider 设置 context 来传递数据
- useDrag 可以传入 type、item、collect 等。type 标识类型，同类型才可以 drop。item 是传递的数据。collect 接收 monitor，可以取拖拽的状态比如 isDragging 返回。
- useDrag 返回三个值，第一个值是 collect 函数返回值，第二个是处理 drag 的元素的函数，第三个值是处理预览元素的函数
- useDrop 可以传入 accept、drop 等。accept 是可以 drop 的类型。drop 回调函数可以拿到 item，也就是 drag 元素的数据
- useDragLayer 的回调函数会传入 monitor，可以拿到拖拽的实时坐标，用来设置自定义预览效果

![image-20240729141755232](../../assets/image-20240729141755232.png)

实现简单拖拽效果

## Demo介绍

先创建三个组件

1. Box组件 拖拽的组件
2. Container组件   可以放容器的组件
3. App组件   布局组件

## 1.初始化

```bash
npm install react-dnd react-dnd-html5-backend
```

```tsx
import './App.css';
import { DndProvider } from "react-dnd"
import { HTML5Backend } from "react-dnd-html5-backend"


function Box() {
  return <div className='box'></div>
}

function Container() {
  return <div className="container"></div>
}

function App() {
  return (
    <DndProvider backend={HTML5Backend} >
      <div>
        <Container></Container>
        <Box></Box>
      </div>
    </DndProvider>
  )
}

export default App;

```

## 2.修改Box组件和Container组件（可以放入动画）

> 1. 用 useDrag 让元素可以拖拽
> 2.  useRef 保存 dom 引用，然后用 useDrag 返回的第二个参数处理它
> 3. useDrop 让它可以接受拖拽过来的元素,
>    - useDrop 让它可以接受拖拽过来的元素

1. 让Box组件可以实现拖拽
2. 可以让Container组件实现保存DOM引用,用 useDrag 返回的第二个参数处理它

```tsx
//box组件

function Box() {
  const ref = useRef(null);

  const [, drag]= useDrag({
    type: 'box',
    item: {
      color: 'blue'
    }
  });

  drag(ref);

  return <div ref={ref} className='box'></div>
}
```

```tsx
// Container组件

function Container() {
  const ref = useRef(null);

  const [,drop] = useDrop(() => {
    return {
      accept: 'box',
      drop(item) {
        console.log(item);
      }
    }
  });
  drop(ref);

  return <div ref={ref} className="container"></div>
}
```

注意点：

1. 这个useDrag的type值要和useDrop的accept值要一样，否则是不允许放入的

```tsx
const [, drag] = useDrag({
    type: 'box',
    item: {
      color: 'blue'
    }
  });
  

  const [, drop] = useDrop(() => {
    return {
      accept: 'box',
      drop(item) {
        console.log(item);
      }
    }
  });
```

## 3.修改Box组件和Container组件（放入实现）

```tsx
// Box 组件

interface ItemType {
  color: string;
}
interface BoxProps {
  color: string
}
function Box(props: BoxProps) {
  const ref = useRef(null);

  const [, drag]= useDrag({
    type: 'box',
    item: {
      color: props.color
    }
  });

  drag(ref);

  return <div ref={ref} className='box' style={
    { background: props.color || 'blue'}
  }></div>
}

```

```tsx
//  Container组件

function Container() {
  const [boxes, setBoxes] = useState<ItemType[]>([]);

  const ref = useRef(null);

  const [,drop] = useDrop(() => {
    return {
      accept: 'box',
      drop(item: ItemType) {
        setBoxes((boxes) => [...boxes, item])
      }
    }
  });
  drop(ref);

  return <div ref={ref} className="container">
    {
      boxes.map(item => {
        return <Box color={item.color}></Box>
      })
    }
  </div>
}

```

这样，拖拽到容器里的功能就实现了

## 4.拖拽过程中的效果（被拖转过程中拖拽物）

1. useDrag 可以传一个 collect 的回调函数，它的参数是 monitor，可以拿到拖拽过程中的状态
2. collect 的返回值会作为 useDrag 的返回的第一个值
3. 根据这个值修改css就好了

![image-20240729143857162](../../assets/image-20240729143857162.png)

```tsx
function Box(props: BoxProps) {
  const ref = useRef(null);

  const [{dragging}, drag]= useDrag({
    type: 'box',
    item: {
      color: props.color
    },
    collect(monitor) {
      return {
        dragging: monitor.isDragging()
      }
    }
  });

  drag(ref);

  return <div ref={ref} className={ dragging ? 'box dragging' : 'box'} style={
    { background: props.color || 'blue'}
  }></div>
}
```

## 5.加拖拽过程中的效果（拖拽预览样式的修改）

1. 新创建一个组件
2. useDragLayer 的参数是函数，能拿到 monitor，从中取出很多东西，比如 item、isDragging，还是有 clientOffset，也就是拖拽过程中的坐标

![image-20240729144130246](../../assets/image-20240729144130246.png)

```tsx
const DragLayer = () => {
  const { isDragging, item, currentOffset} = useDragLayer((monitor) => ({
      item: monitor.getItem(),
      isDragging: monitor.isDragging(),
      currentOffset: monitor.getSourceClientOffset(),
    }));

    if (!isDragging) {
      return null;
    }
    return (
      <div className='drag-layer' style={{
        left: currentOffset?.x,
        top: currentOffset?.y
      }}>{item.color} 拖拖拖</div>
    );
}

```

![image-20240729144530069](../../assets/image-20240729144530069.png)

## 6.取消默认的预览

```tsx
import './App.css';
import { useRef, useState } from 'react'
import { DndProvider, useDrag, useDrop, useDragLayer } from "react-dnd"
import { HTML5Backend, getEmptyImage } from "react-dnd-html5-backend"


interface ItemType {
  color: string;
}
interface BoxProps {
  color: string
}
function Box(props: BoxProps) {
  const ref = useRef(null);

  const [{ dragging }, drag, dragPreview] = useDrag({
    type: 'box',
    item: {
      color: props.color
    },
    collect(monitor) {
      return {
        dragging: monitor.isDragging()
      }
    }
  });
  drag(ref);
  dragPreview(getEmptyImage())
  return <div ref={ref} className={dragging ? 'box dragging' : 'box'} style={
    { background: props.color || 'blue' }
  }></div>
}
```

关键代码

```js
dragPreview(getEmptyImage())
```

## 7.优化

```tsx
useEffect(() => {
    drag(ref);
    dragPreview(getEmptyImage(), { captureDraggingState: true });
}, [])
```

```tsx
useEffect(()=> {
    drop(ref);
}, []);
```

## 全部代码

```tsx
import { useDrag, useDragLayer, useDrop } from 'react-dnd';
import './App.css';
import { useEffect, useRef, useState } from 'react';
import { getEmptyImage } from 'react-dnd-html5-backend'

interface ItemType {
  color: string;
}
interface BoxProps {
  color: string
}
function Box(props: BoxProps) {
  const ref = useRef(null);

  const [{dragging}, drag, dragPreview]= useDrag({
    type: 'box',
    item: {
      color: props.color
    },
    collect(monitor) {
      return {
        dragging: monitor.isDragging()
      }
    }
  });

  useEffect(() => {
    drag(ref);
    dragPreview(getEmptyImage());
  }, [])

  return <div ref={ref} className={ dragging ? 'box dragging' : 'box'} style={
    { background: props.color || 'blue'}
  }></div>
}

function Container() {
  const [boxes, setBoxes] = useState<ItemType[]>([]);

  const ref = useRef(null);

  const [,drop] = useDrop(() => {
    return {
      accept: 'box',
      drop(item: ItemType) {
        setBoxes((boxes) => [...boxes, item])
      }
    }
  });

  useEffect(()=> {
    drop(ref);
  }, []);

  return <div ref={ref} className="container">
    {
      boxes.map(item => {
        return <Box color={item.color}></Box>
      })
    }
  </div>
}


const DragLayer = () => {
  const { isDragging, item, currentOffset} = useDragLayer((monitor) => ({
      item: monitor.getItem(),
      isDragging: monitor.isDragging(),
      currentOffset: monitor.getSourceClientOffset(),
    }));

    if (!isDragging) {
      return null;
    }
    return (
      <div className='drag-layer' style={{
        left: currentOffset?.x,
        top: currentOffset?.y
      }}>{item.color}拖拖拖</div>
    );
}

function App() {
  return <div>
    <Container></Container>
    <Box color="blue"></Box>
    <Box color="red"></Box>
    <Box color="green"></Box>
    <DragLayer></DragLayer>
  </div>
}

export default App;

```

```tsx
.box {
  width: 50px;
  height: 50px;
  background: blue;
  margin: 10px;
}

.dragging {
  border: 5px dashed #000;
  box-sizing: border-box;
}
.drag-layer {
  position: fixed;
}

.container {
  width: 300px;
  height: 300px;
  border: 1px solid #000;
}
```

